# imports
import argparse
import json
from ggCaller.graph_traversal import *
import ggCaller_cpp
from functools import partial
# from memory_profiler import profile
from balrog.__main__ import *
from ggCaller.shared_memory import *
from panaroo_runner import *

def get_options():
    description = 'Generates ORFs from a Bifrost graph.'
    parser = argparse.ArgumentParser(description=description,
                                     prog='ggcaller')

    IO = parser.add_argument_group('Input/Output options')
    IO.add_argument('--graph',
                    default=None,
                    help='Bifrost GFA file generated by Bifrost build. ')
    IO.add_argument('--colours',
                    default=None,
                    help='Bifrost colours file generated by Bifrost build.  ')
    IO.add_argument('--not-ref',
                    action="store_false",
                    default=True,
                    help='If using existing graph, was not graph built exclusively with assembled genomes.  '
                         '[Default = False] ')
    IO.add_argument('--refs',
                    default=None,
                    help='List of reference genomes (one file path per line). ')
    IO.add_argument('--reads',
                    default=None,
                    help='List of read files (one file path per line). ')
    IO.add_argument('--codons',
                    default=None,
                    help='JSON file containing start and stop codon sequences. ')
    IO.add_argument('--kmer',
                    type=int,
                    default=31,
                    help='K-mer size used in Bifrost build (bp). '
                         '[Default = 31] ')
    IO.add_argument('--threads',
                    type=int,
                    default=1,
                    help='Number of threads to use. '
                         '[Default = 1] ')
    IO.add_argument('--out',
                    default='calls.fasta',
                    help='Output FASTA file containing ORF sequences. ')
    Settings = parser.add_argument_group('Cut-off settings')
    Settings.add_argument('--max-path-length',
                          type=int,
                          default=10000,
                          help='Maximum path length during ORF finding (bp). '
                               '[Default = 10000] ')
    Settings.add_argument('--min-orf-length',
                          type=int,
                          default=90,
                          help='Minimum ORF length to return (bp). '
                               '[Default = 90] ')
    Settings.add_argument('--max-ORF-overlap',
                          type=int,
                          default=60,
                          help='Maximum overlap allowed between overlapping ORFs. '
                               '[Default = 60] ')
    Settings.add_argument('--min-path-score',
                          type=int,
                          default=100,
                          help='Minimum total Balrog score for a path of ORFs to be returned. '
                               '[Default = 100] ')
    Settings.add_argument('--min-orf-score',
                          type=int,
                          default=100,
                          help='Minimum individual Balrog score for an ORF to be returned. '
                               '[Default = 100] ')
    Settings.add_argument('--max-orf-orf-distance',
                          type=int,
                          default=10000,
                          help='Maximum distance for graph traversal during ORF connection (bp). '
                               '[Default = 10000] ')
    Settings.add_argument('--identity-cutoff',
                          type=float,
                          default=0.98,
                          help='Minimum identity at amino acid level between two ORFs for clustering. '
                               '[Default = 0.98] ')
    Settings.add_argument('--len-diff-cutoff',
                          type=float,
                          default=0.98,
                          help='Minimum ratio of length between two ORFs for clustering.  '
                               '[Default = 0.98] ')
    Algorithm = parser.add_argument_group('Settings to avoid/include algorithms')
    Algorithm.add_argument('--no-filter',
                           action="store_true",
                           default=False,
                           help='Do not filter ORF calls using Balrog. Will return all ORF calls. '
                                '[Default = False] ')
    Algorithm.add_argument('--no-write-idx',
                           action="store_false",
                           default=True,
                           help='Do not write FMIndexes to file. '
                                '[Default = False] ')
    Algorithm.add_argument('--no-write-graph',
                           action="store_false",
                           default=True,
                           help='Do not write Bifrost GFA and colours to file. '
                                '[Default = False] ')
    Algorithm.add_argument('--repeat',
                           action="store_true",
                           default=False,
                           help='Enable traversal of nodes multiple times. '
                                '[Default = False] ')
    Algorithm.add_argument('--no-clustering',
                           action="store_true",
                           default=False,
                           help='Do not cluster ORFs. '
                                '[Default = False] ')
    return parser.parse_args()

def main():
    options = get_options()

    # parse command line arguments
    options.out = options.out

    # define start/stop codons
    if options.codons != None:
        with open(options.codons, "r") as json_file:
            try:
                data = json.load(json_file)
                start_codons = data["codons"]["start"]
                stop_codons_for = data["codons"]["stop"]
                stop_codons_rev = [str((Seq(i)).reverse_complement()) for i in stop_codons_for]
            except:
                print("Please specify codons in the format shown in codons.json.")
                sys.exit(1)
    else:
        start_codons = ["ATG", "GTG", "TTG"]
        stop_codons_for = ["TAA", "TGA", "TAG"]
        stop_codons_rev = ["TTA", "TCA", "CTA"]

    # initialise graph
    graph = ggCaller_cpp.Graph()

    # if build graph specified, build graph and then call ORFs
    if (options.graph != None) and (options.colours != None) and (options.refs == None) and (options.reads == None):
        graph_tuple = graph.read(options.graph, options.colours, stop_codons_for, stop_codons_rev,
                                 options.threads, True)
    # if refs file specified for building
    elif (options.graph == None) and (options.colours == None) and (options.refs != None) and (options.reads == None):
        graph_tuple = graph.build(options.refs, options.kmer, stop_codons_for, stop_codons_rev,
                                  options.threads, True, options.no_write_graph, "NA")
    # if reads file specified for building
    elif (options.graph == None) and (options.colours == None) and (options.refs == None) and (options.reads != None):
        graph_tuple = graph.build(options.reads, options.kmer, stop_codons_for, stop_codons_rev,
                                  options.threads, False, options.no_write_graph, "NA")
    # if both reads and refs file specified for building
    elif (options.graph == None) and (options.colours == None) and (options.refs != None) and (options.reads != None):
        graph_tuple = graph.build(options.refs, options.kmer, stop_codons_for, stop_codons_rev,
                                  options.threads, False, options.no_write_graph, options.reads)
    else:
        print("Error: incorrect number of input files specified. Please only specify the below combinations:\n"
              "- Bifrost GFA and Bifrost colours file\n"
              "- List of reference files\n"
              "- List of read files\n"
              "- A list of reference files and a list of read files.")
        sys.exit(1)

    # unpack ORF pair into overlap dictionary and list for gene scoring
    node_colour_vector, input_colours, nb_colours, overlap = graph_tuple

    # create numpy arrays for shared memory
    total_arr = np.array([graph])

    # load balrog models if required
    if not options.no_filter:
        print("Loading gene models...")
        model, model_tis = load_gene_models()

    else:
        model, model_tis = None, None, None

    # intiialise results dictionaries and lists
    high_scoring_ORFs = {}
    high_scoring_ORF_edges = {}
    cluster_id_list = None
    cluster_dict = None

    # use shared memory to generate graph vector
    print("Generating high scoring ORF calls...")

    # set number of threads for graphtool and pytorch to 1
    if gt.openmp_enabled():
        gt.openmp_set_num_threads(1)

    torch.set_num_threads(1)

    with SharedMemoryManager() as smm:
        # generate shared numpy arrays
        total_arr = np.append(total_arr, [[model], [model_tis]])
        array_shd, array_shd_tup = generate_shared_mem_array(total_arr, smm)

        # run run_calculate_ORFs with multithreading
        with Pool(processes=options.threads) as pool:
            for colour_ID, gene_dict, ORF_edges in pool.map(
                    partial(run_calculate_ORFs, shd_arr_tup=array_shd_tup, repeat=options.repeat, overlap=overlap,
                            max_path_length=options.max_path_length, is_ref=options.not_ref,
                            no_filter=options.no_filter,
                            stop_codons_for=stop_codons_for, start_codons=start_codons,
                            min_ORF_length=options.min_orf_length,
                            max_ORF_overlap=options.max_ORF_overlap, minimum_ORF_score=options.min_orf_score,
                            minimum_path_score=options.min_path_score, write_idx=options.no_write_idx,
                            input_colours=input_colours, max_orf_orf_distance=options.max_orf_orf_distance),
                    enumerate(node_colour_vector)):
                high_scoring_ORFs[colour_ID] = gene_dict
                high_scoring_ORF_edges[colour_ID] = ORF_edges

            # generate ORF clusters
            if not options.no_clustering:
                print("Generating clusters of high-scoring ORFs...")
                cluster_id_list, cluster_dict = graph.generate_clusters(high_scoring_ORFs,
                                                                        overlap,
                                                                        options.identity_cutoff,
                                                                        options.len_diff_cutoff)

    # for testing
    print("high_scoring_ORFs: " + str(len(high_scoring_ORFs)))
    print("high_scoring_ORF_edges: " + str(len(high_scoring_ORF_edges)))
    print("cluster_id_list: " + str(len(cluster_id_list)))
    print("cluster_dict: " + str(len(cluster_dict)))

    print("Finished.")

    sys.exit(0)


if __name__ == '__main__':
    main()
